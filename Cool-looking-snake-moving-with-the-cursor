<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Smooth Snake â€” Cursor Follower</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #07111a;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        body {
            cursor: none;
        }

        /* we draw our own head so hide native cursor */
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d', { alpha: false });

        let W = window.innerWidth;
        let H = window.innerHeight;
        canvas.width = W;
        canvas.height = H;

        window.addEventListener('resize', () => {
            W = window.innerWidth; H = window.innerHeight;
            canvas.width = W; canvas.height = H;
            initSnake();
        });

        // Mouse / touch target
        const target = { x: W / 2, y: H / 2 };
        window.addEventListener('mousemove', e => {
            target.x = e.clientX;
            target.y = e.clientY;
        });
        window.addEventListener('pointerdown', e => {
            target.x = e.clientX; target.y = e.clientY;
        });
        window.addEventListener('touchmove', e => {
            if (e.touches && e.touches[0]) {
                target.x = e.touches[0].clientX;
                target.y = e.touches[0].clientY;
            }
        }, { passive: true });

        // Utility
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

        // Snake config
        const SEGMENTS = 80;            // body resolution (more = smoother)
        const SEGMENT_SPACING = 8;     // distance between segments
        const HEAD_SPEED = 0.18;       // how fast head moves toward cursor
        const TAIL_STIFFNESS = 0.45;   // how tightly segments follow
        const BODY_WIDTH = 36;         // head width (body tapers)
        const COLORS = {
            bodyA: '#37684a',
            bodyB: '#9fd08b',
            belly: '#f0e6c9',
            eye: '#0b0b0b',
            tongue: '#ff3b3b'
        };

        // State: positions of segment centers (0 = head)
        let segments = [];

        // Initialize snake in middle
        function initSnake() {
            segments = [];
            const startX = W / 2;
            const startY = H / 2;
            for (let i = 0; i < SEGMENTS; i++) {
                segments.push({ x: startX - i * SEGMENT_SPACING, y: startY, angle: 0 });
            }
        }
        initSnake();

        // Draw rounded body as series of circles blended (fast & stable)
        function drawBody() {
            // Draw thick body by drawing circles from head to tail with width taper
            for (let i = 0; i < segments.length; i++) {
                const p = segments[i];
                // taper width from head to tail
                const t = i / (segments.length - 1);
                const w = BODY_WIDTH * (1 - 0.85 * t) + 2; // +2 so tail is not zero
                // color gradient along body
                const r = lerpHex(COLORS.bodyA, COLORS.bodyB, t);
                // belly ellipse (slightly offset)
                const bellyW = w * 0.6;
                ctx.beginPath();
                ctx.fillStyle = r;
                ctx.arc(p.x, p.y, w / 2, 0, Math.PI * 2);
                ctx.fill();

                // belly highlight (underbelly)
                ctx.beginPath();
                ctx.fillStyle = COLORS.belly;
                ctx.ellipse(p.x - Math.cos(p.angle) * w * 0.12, p.y - Math.sin(p.angle) * w * 0.12, bellyW * 0.6, bellyW * 0.35, p.angle, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Helper to interpolate hex colors (simple)
        function lerpHex(a, b, t) {
            const pa = hexToRgb(a);
            const pb = hexToRgb(b);
            const r = Math.round(lerp(pa.r, pb.r, t));
            const g = Math.round(lerp(pa.g, pb.g, t));
            const bl = Math.round(lerp(pa.b, pb.b, t));
            return `rgb(${r},${g},${bl})`;
        }
        function hexToRgb(hex) {
            // accept #rrggbb or #rgb
            hex = hex.replace('#', '');
            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
            const n = parseInt(hex, 16);
            return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
        }

        // Draw head with eyes & tongue
        let tongueTimer = 0;
        function drawHead() {
            const head = segments[0];
            const next = segments[1];
            const angle = Math.atan2(next.y - head.y, next.x - head.x) + Math.PI;

            ctx.save();
            ctx.translate(head.x, head.y);
            ctx.rotate(angle);

            const headLength = BODY_WIDTH * 1.2;
            const headWidth = BODY_WIDTH * 0.8;

            // Snake head (diamond shape)
            ctx.beginPath();
            ctx.moveTo(0, -headWidth * 0.5);                  // top point
            ctx.lineTo(headLength * 0.6, 0);                  // snout
            ctx.lineTo(0, headWidth * 0.5);                   // bottom point
            ctx.lineTo(-headLength * 0.6, headWidth * 0.4);   // back right
            ctx.lineTo(-headLength * 0.6, -headWidth * 0.4);  // back left
            ctx.closePath();
            ctx.fillStyle = COLORS.bodyA;
            ctx.fill();
            ctx.strokeStyle = "#222";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Eyes
            ctx.fillStyle = COLORS.eye;
            ctx.beginPath();
            ctx.ellipse(headLength * 0.25, -headWidth * 0.25, 4, 6, 0, 0, Math.PI * 2);
            ctx.ellipse(headLength * 0.25, headWidth * 0.25, 4, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Forked tongue
            tongueTimer += 0.15;
            if (Math.random() < 0.02) tongueTimer = 0;
            const flick = Math.sin(tongueTimer * 12) * 10;

            ctx.strokeStyle = COLORS.tongue;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(headLength * 0.65, 0);
            ctx.lineTo(headLength * 0.65 + 20 + flick, -4);
            ctx.moveTo(headLength * 0.65, 0);
            ctx.lineTo(headLength * 0.65 + 20 + flick, 4);
            ctx.stroke();

            ctx.restore();
        }


        // Update snake kinematics
        function update(dt) {
            // Move head toward target
            const head = segments[0];
            // direction vector to target
            const dx = target.x - head.x;
            const dy = target.y - head.y;
            // move head toward cursor with smoothing
            head.x += dx * HEAD_SPEED;
            head.y += dy * HEAD_SPEED;

            // compute angles for head
            head.angle = Math.atan2(head.y - segments[1].y, head.x - segments[1].x);

            // Each segment follows the previous using a simple follow algorithm
            for (let i = 1; i < segments.length; i++) {
                const prev = segments[i - 1];
                const cur = segments[i];
                // desired position is at SEGMENT_SPACING distance behind prev
                const vx = cur.x - prev.x;
                const vy = cur.y - prev.y;
                const d = Math.hypot(vx, vy) || 0.0001;
                // normalize
                const nx = vx / d;
                const ny = vy / d;
                // target position for this segment:
                const tx = prev.x + nx * SEGMENT_SPACING;
                const ty = prev.y + ny * SEGMENT_SPACING;
                // ease toward the target position
                cur.x = lerp(cur.x, tx, TAIL_STIFFNESS);
                cur.y = lerp(cur.y, ty, TAIL_STIFFNESS);
                // angle
                cur.angle = Math.atan2(cur.y - prev.y, cur.x - prev.x);
            }
        }

        // Main loop
        let last = performance.now();
        function loop(now) {
            const dt = (now - last) / 1000;
            last = now;

            // background
            ctx.fillStyle = '#07111a';
            ctx.fillRect(0, 0, W, H);

            update(dt);

            // draw shadow under snake for depth
            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#000';
            // draw shadow as an elongated blurred ellipse under body
            ctx.beginPath();
            const head = segments[0];
            ctx.ellipse(head.x + 6, head.y + 36, BODY_WIDTH * 1.8, BODY_WIDTH * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // draw snake body (tail to head so head overlaps)
            drawBody();

            // draw head last so it appears on top
            drawHead();

            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        // Init helper
        function seedMouse(x, y) {
            target.x = x; target.y = y;
            segments = [];
            for (let i = 0; i < SEGMENTS; i++) segments.push({ x: x - i * SEGMENT_SPACING, y: y, angle: 0 });
        }
        seedMouse(W / 2, H / 2);
    </script>
</body>

</html>
